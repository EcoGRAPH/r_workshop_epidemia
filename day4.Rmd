---
title: | 
  | Introduction to R for Disease Surveillance 
  | and Outbreak Forecasting: Day 4
subtitle: Developing practical workflows for data exploration
author: |
  | Michael Wimberly & Chris Merkord,
  | Geospatial Sciences Center of Excellence, South Dakota State University
date: July 20 2017, Addis Ababa, Ethiopia
output:
  pdf_document: default
  html_document: default
---

\pagenumbering{gobble}

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Outline

* Preparing data for visualization and analysis
    + Reading
    + Cleaning
    + Creating a custom function
    + Computing derived variables
    + Visualization and analysis
* Exploratory analysis of malaria-environment relationships
    + Exploring environmental data
    + Smoothing
    + Malaria--environment relationships in Fogera
* Predictive modeling
* Exercises

## Introduction

This tutorial will combine many of the functions that we have studied over the past several days to build practial workflows for processing, visualizing, and analyzing data. In particular, we will focus on the practicalities of working with "real" datasets, including data cleaning, calculating derived variables,  formatting data tables, and conducting basic statistical analyses. These topics will be addressed by presenting  example workflows involving epidemiological surveillance data and environmental monitoring data. After going through the tutorial and completing the exercises at the end, you will have a better idea of how to develop R scripts that will allow to you automate data processing tasks and generate useful outputs.

## Preparing data for visualization and analysis

We will start by loading several of the packages that we have used in this workshop.

```{r}
library(dplyr)
library(tidyr)
library(ggplot2)
library(readr)
library(lubridate)
```

We will also need to load the custom functions for converting between dates and epidemiological weeks. These functions are stored in a separate script. Running the `source()` function will automatically run the entire script and create these functions as objects in our workspace.

```{r}
source("epiweek_functions.R")
```
### Reading

We will first read in a comma-delimited (.csv) data file using `read_csv()` function.

```{r read_epi_data}
morb_data <- read_csv(file = "epidemia_morb_data.csv")
```

After reading the data, `read_csv()` supplies a message with information about how the data was imported. By default, most columns were imported as integers, which makes sense because they typically represent counts of individuals. Zone and woreda names are imported as characters. Empty columns are imported as characters by default. Any empty value is assigned an NA value based on the default value of the `na` argument which can be viewed in the documentation for `read_csv()`.

You can get a list of all the field names and their associated data types using `spec()` from the readr package.

```{r readepidata2}
spec(morb_data)
```

You can see that most of the variable names are surrounded by backticks `\``. That is because they contain spaces or other non-standard characters. To work with these columns, you also need to wrap the variable names in backticks.

### Cleaning

`read_csv()` makes it convenient to get a structured data frame with a single command. However, the table has a large number of fields (more than we need to work with) and the field names, although easy to understand, are difficult to type because they are long and have multiple spaces. Therefore, we need to take a number of steps to clean and simplify the dataset to prepare it for analysis. 

The first step involves selecting a subset of these variables that we are going to use and assigning shorter field names to these variables. 

```{r clean_epi_data1}
cln_morb_data <- 
  rename(
    morb_data,
    woreda = Woreda,
    year = Year,
    epiweek = Epiweek,
    rdt_pfonly = `RDT P. falciparum-only`,
    rdt_pfmix = `RDT P. falciparum`,
    rdt_mix = `RDT Mixed Infections`,
    rdt_pvonly = `RDT P. vivax-only`,
    bf_pfonly = `Blood Films P. falciparum-only`,
    bf_pfmix = `Blood Films P. falciparum`,
    bf_mix = `Blood Films Mixed Infections`,
    bf_pvonly = `Blood Films P. vivax-only`,   
    rdt_test = `RDTs Done`,
    bf_test = `Blood Films Done`,
    mal_case = `Malaria Cases`,
    mal_out = `Malaria Outpatient Cases`,
    tot_case = `Total Cases`,
    tot_out = `Total Outpatient Cases`,
    pop = Population
  )

cln_morb_data <- 
  select(
    cln_morb_data,
    woreda, year, epiweek, rdt_pfonly, rdt_pfmix, rdt_mix, rdt_pvonly, bf_pfonly,
    bf_pfmix, bf_mix, bf_pvonly, rdt_test, bf_test, mal_case, mal_out, tot_case,
    tot_out, pop
  )
cln_morb_data
```

### Creating a custom function

Earlier in this tutorial, we ran another script to load some custom functions that we need for date conversions. To help you better understand how functions work, we will create out own custom function and use it to compute malaria indicators in the next data processing step.

```{r makefunction}
comp_ind <- function(num, den, mult=100) {
  den[den <= 0] <- NA
  ratio <- mult * num/den
}
comp_ind
class(comp_ind)
mycases <- c(34, 26, 57, 45)
mydenom <- c(439, 0, 584, 226)
100 * mycases/mydenom
print(comp_ind(num=mycases, den=mydenom))
print(comp_ind(num=mycases, den=mydenom, mult=10000))
```

Note that the custom function allows us to accomplish two steps with a single line of code. First, the function checks for any zeroes in the denomiator values and converts them to NA so that we do not end up with infinite values for our ratios. Second, the ratio of numerator to denominator is calculated and expanded by the multiplier. If no `mult` argument is provided, then a default value of 100 is used to give the result as a precentage.

### Computing derived variables

The next step involves computing derived variables that express malaria burden as incidence rates, percent of total cases, and percent positive tests. Malaria indicators are computed separately for all malaria cases, *Plasmodium falciparum*/mixed cases, and *Plasmodium vivax* only cases. The custom `comp_ind()` function is used to compute the malaria indicators.

```{r clean_epi_data2}
cln_morb_data <-  
  mutate(
    cln_morb_data, 
    wdate = make_date_yw(year, epiweek),
    doy = yday(wdate),
    pfconf1 = rdt_pfonly + rdt_mix + bf_pfonly + bf_mix,
    pfconf2 = rdt_pfmix + bf_pfmix,
    pfconf = ifelse(!is.na(pfconf1), pfconf1,
                    ifelse(!is.na(pfconf2), pfconf2, NA)),
    pvconf = rdt_pvonly + bf_pvonly,
    alltest = rdt_test + bf_test,
    allconf = pfconf + pvconf,
    allmal = ifelse(!is.na(mal_case), mal_case,
                    ifelse(!is.na(mal_out), mal_out, NA)),
    allcase = ifelse(!is.na(tot_case), tot_case,
                     ifelse(!is.na(tot_out), tot_out, NA)),
    pfinc = comp_ind(num=pfconf, den=pop, mult=10000),
    pvinc = comp_ind(num=pvconf, den=pop, mult=10000),
    allinc = comp_ind(num=allmal, den=pop, mult=10000),
    pfpod = comp_ind(num=pfconf, den=allcase),
    pvpod = comp_ind(num=pvconf, den=allcase),
    allpod = comp_ind(num=allmal, den=allcase),
    pfppt = comp_ind(num=pfconf, den=alltest),
    pvppt = comp_ind(num=pvconf, den=alltest),
    allppt = comp_ind(num=allconf, den=alltest)
  )
```

Finally, we will use the filter function to choose a subset of the records. We will use data from four woredas over four years, 2013--2016. Note that this step is not really necessary in this demonstration because we are using a small dataste that encompasses only these woredas and years. However, we provide the code here as an example of how a larger database could be filtered.

```{r clean_epi_data3}
cln_morb_data <- filter(
  cln_morb_data, 
  woreda %in% c("Fogera", "Mecha", "Metema", "Jabi Tehnan"),
  year %in% 2013:2016
)
cln_morb_data
```

Below is a list of the derived fields that we are going to work with in the subsequent examples

**woreda** woreda name  
**wdate** date of the first day of the epidemiological week  
**doy** day of year  
**year** year  
**epiweek** epidemiological week 
**pfconf** total number of confirmed *P. falciparum* or mixed cases  
**pvconf** total number of confirmed *P. vivax* only cases  
**allconf** total number of all confirmed malaria cases  
**alltest** total number of malaria tests performed (including blood films and RDTs)  
**allmal** total number of malaria cases (including confirmed + clinical diagnoses)  
**allcase** total number of outpatient cases (including malaria as well as other complaints)  
**pfinc** incidence of confirmed *P. falicparum* or mixed species malaria per 10,000 population  
**pvinc** incidence of confirmed *P. vivax* only malaria per 10,000 population  
**allinc** incidence of all confirmed or unconfirmed malaria per 10,000 population  
**pfpod** percent of outpatient cases diagnosed with confirmed *Plasmoidum falciparum* or mixed malaria  
**pvpod** percent of outpatient cases diagnosed with confirmed *Plasmodium vivax* only malaria  
**allpod** percent of outpateitn cases dianosed with any type of confirmed or unconfirmed malaria  
**pfppt** percent of positive tests for confirmed *Plasmoidum falciparum* or mixed malaria  
**pvppt** percent of positive tests for confirmed *Plasmodium vivax* only malaria  
**allppt** percent of positive tests for any type of confirmed or unconfirmed malaria  

### Visualization and analysis

To visualize these data, we will generate a plot of weekly malaria incidence on the y axis versus time on the x axis. The data for each woreda will be plotted as different colored lines.

```{r}
ggplot(cln_morb_data) +
  geom_line(aes(x = wdate, y = allinc, color = woreda)) +
  labs(x = "Time", y = "Malaria Incidence per 10,000")
```

This plot shows some interesting similarities and differences among the temporal signatures of malaria in these four woredas. We can use a relatively simple correlation analysis to quantify the degree of synchrony among the districts. But first we need to create a new "wide" version of the dataset that has a separate field for the malaria incidence in each woreda. We can do this by using `select()` to choose the fields that we want to include in the new dataset, and then using `spread()` to generate a separate field for malaria incidence in each woreda.

```{r}
cor_data <- select(cln_morb_data, wdate, woreda, allinc)
cor_data <- spread(cor_data, woreda, allinc)
cor_data <- select(cor_data, -wdate)
```

The `cor()` function will compute all pairwide correlations when data frame consisting of only numeric fields is provided as an argument. Our data frame has dates in the first column, so we will use subscripting to remove the date field.

```{r}
cor(cor_data)
```

Note that the Metema data field has one `NA` value. By default, `cor()` will return `NA` for all correlations including Metema. We can obtain a valid correlation by using only complete, pairwise observations by setting the `use` argument to `"pairwise.complete.obs"`. We can also set `method` argument to `"spearman"` to obtain a non-parametric rank-based correlation coefficient.

```{r}
summary(cor_data)
cor(cor_data, use = "pairwise.complete.obs")
cor(cor_data, use = "pairwise.complete.obs", method = "spearman")
```

It is also of interest to ask whether there is concordance among our various malaria indicators. To visualize this concordance, let us create a time series plot with different line colors for each indicator (incidence, percent of outpatient cases, and percent positive tests) and facets for each woreda.

In ggplot terminology, we want to map color to indicator However, our data frame `cln_morb_data` does not have a column with indicator names to use for mapping. Instead, indicator names are found in the column headings. To transform the data into the necessary shape, you must use `gather()` to create new variables containing indicator name and indicator value. We will call these `"ind_name"` and `"ind_value"`.

```{r}
long_morb_data <- gather(cln_morb_data, 
                         key = "ind_name", value = "ind_value", 
                         allinc, allpod, allppt)
long_morb_data <- select(long_morb_data, woreda, wdate, ind_name, ind_value)
```

Now you can plot the data using `ggplot()`.

```{r}
# plot indicators
ggplot(long_morb_data) +
  geom_line(aes(x = wdate, y = ind_value, color = ind_name)) +
  facet_wrap(~ woreda, ncol = 2, scales = "free_y") +
  labs(x = "Time", y = "Indicator Value", 
       color = "Indicator\nName")                    # change legend names
```

We can also plot these data in differnt ways. For example, the following scatterplot shows the relationship between malaria incidence and percent of outpatients diagnosed with malaria for each woreda, with each year represented as a different color.

```{r}
# plot percent of outpatients diagnosed with malaria
ggplot(cln_morb_data, aes(x = allinc, y = allpod)) +
  geom_point(aes(color = factor(year))) + 
  facet_wrap(~ woreda, ncol = 2, scales = "free") +
  labs(x = "Malaria Incidence per 10,000", 
       y = "Percent of Outpatients Diagnosed with Malaria",
       color = "Year")
```

One way to quantify these relationship is to fit a linear model. Here, we fit an ordinary least squares regression model of the logarithm of malaria incidence (dependent variable) as a function of percent of malaria outpatients diagnosed with malaria (independent variable). Note that `lm()` has a `subset` argument that works much like `dplyr::filter()`

```{r}
fogera_lm <- lm(log(allinc + 1) ~ allpod, 
                data = cln_morb_data, 
                subset = woreda == "Fogera")
summary(fogera_lm)

metema_lm <- lm(log(allinc + 1) ~ allpod, 
                data = cln_morb_data, 
                subset = woreda == "Metema")
summary(metema_lm)
```

## Exploratory analysis of malaria-environment relationships

### Exploring environmental data

To examine malaria--environment relationships, we will work with a new dataset containing weekly summaries of malaria indicators and environmental variables. These data are automatically generated by the EPIDEMIA system and can be downloaded through the query interface of the EPIDEMIA website. 

```{r, message=FALSE}
env_data <- read_csv("epidemia_proc_data.csv")
```

As with the previous example, we will take various steps to update and clean the dataset. These data have already gone through a number of cleaning and pre-processing steps in the EPIDEMIA system, so there is less to do here. We will go through the same steps of renaming variables, selecting variables, computing derived variables, and filtering that we used previously.

```{r}
cln_env_data <- rename(
  env_data,
  woreda = Woreda, 
  epiweek = Epiweek, 
  epiyear = Year,
  allinc = `Malaria Incidence`,
  pvinc = `Incidence  of P. vivax-only Malaria`,
  pfinc = `Incidence of P. falciparum Malaria`,
  lstd = `Daytime Land Surface Temperature (LST)`,
  precip = `GPM Composite Rainfall`,
  alstd = `Daytime Land Surface Temperature (LST) Anomaly`,
  aprecip = `GPM Composite Rainfall Anomaly`
)
cln_env_data <- select(
  cln_env_data,
  woreda, epiweek, epiyear, allinc, pvinc, pfinc, lstd, precip, alstd, aprecip
)
cln_env_data <- mutate(
  cln_env_data,
  wdate = make_date_yw(epiyear, epiweek), 
  doy = yday(wdate), 
  year = year(wdate) 
) 
cln_env_data <- filter(
  cln_env_data, 
  woreda %in% c("Fogera", "Mecha", "Metema", "Jabi Tehnan"),
  year %in% 2013:2016
)
cln_env_data
```

Variable names are as follows:

> **woreda** woreda name  
**wdate** date of the first day of the epidemiological week  
**doy** day of year  
**epiweek** epidemiological week  
**epiyear** epidemiological year  
**allinc** incidence of all confirmed or unconfirmed malaria per 10,000 population  
**pfinc** incidence of confirmed *P. falicparum* or mixed species malaria per 10,000 population  
**pvinc** incidence of confirmed *P. vivax*-only malaria per 10,000 population  
**lstd** daytime land surface temperature (°C)  
**precip** weekly precipitation total (mm)  
**alstd** land surface temperature anomaly (°C)  
**aprecip** precipitation anomaly (°C)

To explore these environmental data, we will first generate some time series plots.

```{r, fig.height=2.5}
# plot malaria incidence
ggplot(cln_env_data) +
  geom_line(aes(x = wdate, y = allinc, color = woreda)) +
  labs(x = "Time", y = "Malaria Incidence per 10,000")
# plot lst
ggplot(cln_env_data) +
  geom_line(aes(x = wdate, y = lstd, color = woreda)) +
  labs(x = "Time", y = "Weekly Temperature (°C)")
# plot lst anomaly
ggplot(cln_env_data) +
  geom_line(aes(x = wdate, y = alstd, color = woreda)) +
  labs(x = "Time", y = "Weekly Temp. Anomaly (°C)")
```

We can also explore the data using summary tables. Here's a simple summary of mean temperature and total precipitation by woreda and year

```{r}
ann_env_data <- group_by(
  cln_env_data,
  woreda, epiyear)
ann_env_data <- summarize(
  ann_env_data,
  mannlst = mean(lstd),
  tannprec = sum(precip)
)
ann_env_data <- ungroup(
  ann_env_data
)

ann_env_data
```

And here a similar example that summarize the same data only for the rainy season (weeks 21-35)

```{r}
rain_env_data <- group_by(
  cln_env_data,
  woreda, epiyear)
rain_env_data <- filter(
  rain_env_data,
  epiweek >= 21 & epiweek <= 25
)
rain_env_data <- summarize(
  rain_env_data,
  mannlst = mean(lstd),
  tannprec = sum(precip)
)
rain_env_data <- ungroup(
  rain_env_data
)

ann_env_data
```

If needed, we can export these summaries to various file types

```{r}
write_csv(rain_env_data, "rainy_season_env_summary.csv")
```

### Smoothing data

One of the issues with these data is that they are noisy---values tend to follow broader trends, but also jump up and down from week to week. Some of this week to week variability may be part of the real signal, but much of it may be a result of missing observations and measurement errors. 

It may be possible to see the patterns more clearly if we smooth the data. We will do this using a four-week rolloing window. For each week, we will calculate the mean of the values during the current and three preceding weeks. As before, we will use `mutate()` to add new variables to the data frame, but we will use a special function from the zoo package for time series analysis that will allow us to easily calculate the rolling means. We will also use `group_by()` to ensure the rolling means are calculated independently for each woreda.

```{r, message=FALSE}
library(zoo)
```


```{r}
smth_env_data <- group_by(cln_env_data, woreda) 
smth_env_data <- mutate(
  smth_env_data, 
  rallinc = rollapply(allinc, width = 4, FUN = mean, 
                      na.rm = TRUE, fill = NA, align = "left"),
  rlstd = rollapply(lstd, width = 4, FUN = mean, 
                    na.rm = TRUE, fill = NA, align = "left"),
  ralstd = rollapply(alstd, width = 4, FUN = mean, 
                     na.rm = TRUE, fill = NA, align = "left"),
  rprecip = rollapply(precip, width = 4, FUN = mean, 
                      na.rm = TRUE, fill = NA, align = "left"),
  raprecip = rollapply(aprecip, width = 4, FUN = mean, 
                       na.rm = TRUE, fill = NA, align = "left"),
  rallinc4 = lag(rallinc, 4),
  ralstd4 = lag(ralstd, 4),
  ralstd8 = lag(ralstd, 8),
  ralstd12 = lag(ralstd, 12), 
  raprecip4 = lag(raprecip, 4),
  raprecip8 = lag(raprecip, 8),
  raprecip12 = lag(raprecip, 12),
  cos1 = cos(2 * pi * 1 * doy / 365),
  sin1 = sin(2 * pi * 1 * doy / 365),
  cos2 = cos(2 * pi * 2 * doy / 365),
  sin2 = sin(2 * pi * 2 * doy / 365)
)
smth_env_data <- ungroup(smth_env_data)
```

Now let's plot the smoothed data.

```{r, fig.height=2.5, warning=FALSE}
# plot smoothed malaria incidence
ggplot(smth_env_data) +
  geom_line(aes(x = wdate, y = rallinc, color = woreda)) +
  xlab("Time") + ylab("Smoothed Malaria\nIncidence per 10,000")
# plot smoothed lst
ggplot(smth_env_data) + 
  geom_line(aes(x = wdate, y = rlstd, color = woreda)) +
  xlab("Time") + ylab("Smoothed Temperature\n(°C)")
# plot smoothed lst anomaly
ggplot(smth_env_data) +
  geom_line(aes(x = wdate, y = ralstd, color = woreda)) +
  xlab("Time") + ylab("Smoothed Temperature\nAnomaly (°C)")
```

### Malaria--environment relationships in Fogera

Let's look more closely at the data for Fogera. To do this, we'll create a new dataset by filtering out Fogera and converting the data into a long format with three variables (incidence, temperature anomaly, and precipitation anomaly) in a single row. Then we'll plot the results with each variable in its own facet and with its own color.

```{r}
fog_env_data <- filter(smth_env_data, woreda == "Fogera")
long_fog_env_data <- gather(fog_env_data, 
                            key = "var_name", value = "value", 
                            allinc, ralstd, raprecip)
long_fog_env_data <- select(long_fog_env_data, woreda, 
                            wdate, var_name, value)
ggplot(long_fog_env_data) +
  geom_line(aes(x = wdate, y = value, color = var_name)) + 
  facet_wrap(~ var_name, ncol=1, scales = "free_y") +
  labs(x = "Time", y = "Value", color = "Variable")
```

Now let's look at correlations between malaria incidence and the temperature and precipitation anomalies computed at a few different lags.

```{r}
cor(select(fog_env_data, rallinc), 
    select(fog_env_data, ralstd4, ralstd8, ralstd12, 
           raprecip4, raprecip8, raprecip12),
    use = "pairwise.complete.obs", 
    method="spearman")
```

## Predictive modeling

We will now explore a few simple time series models for malaria incidence. The first model includes only seasonal effects based on a second-order Fourier harmonic transformation.

```{r, warning=FALSE, fig.height=3}
# fit a seasonal model
seas_lm <- lm(log(rallinc) ~ cos1 + cos2 + sin1 + sin2, 
              data = fog_env_data, 
              na.action = "na.exclude")
summary(seas_lm)

# create a new tibble with observed and fitted values
seas_results <- transmute(
  fog_env_data, 
  wdate, 
  observed = rallinc,
  fitted = fitted(seas_lm),    # get fitted values from model object
  fitted = unname(fitted),     # remove unneccesary names
  fitted = exp(fitted)         # return to original scale
)

# put results in long format for ggplot
seas_results <- gather(seas_results, key = "key", value = "value", -wdate)

ggplot(seas_results) +
  geom_line(aes(x = wdate, y = value, color = key)) +
  labs(x = "Time", y = "Malaria Incidence", 
       title = "Seasonal effects model")
```

Next we will try to improve the model by adding lagged variables for the smoothed temperature and precipitation anomalies.

```{r, warning=FALSE, fig.height=3}
# try adding lagged variables 
env_lm <- lm(log(rallinc) ~ cos1 + cos2 + sin1 + sin2 + 
               ralstd12 + raprecip4, 
             data = fog_env_data, 
             na.action = "na.exclude")
summary(env_lm)

# create a new tibble with observed and fitted values
env_results <- transmute(
  fog_env_data, wdate, observed = rallinc,
  fitted = exp(unname(fitted(env_lm))))

# put results in long format for ggplot
env_results <- gather(env_results, key = "key", value = "value", -wdate)

ggplot(env_results) +
  geom_line(aes(x = wdate, y = value, color = key)) +
  labs(x = "Time", y = "Malaria Incidence", 
       title = "Seasonal and lagged environmental effects model")
```

We can also try adding an autoregressive term.

```{r, warning=FALSE, fig.height=3}
# try adding an autoregressive term
auto_lm <- lm(log(rallinc) ~ cos1 + cos2 + sin1 + sin2 + 
                ralstd12 + rallinc4, 
              data = fog_env_data, 
              na.action = "na.exclude")
summary(auto_lm)

# create a new tibble with observed and fitted values
auto_results <- transmute(
  fog_env_data, wdate, observed = rallinc,
  fitted = exp(unname(fitted(auto_lm))))

# put results in long format for ggplot
auto_results <- gather(auto_results, key = "key", value = "value", -wdate)

ggplot(auto_results) +
  geom_line(aes(x = wdate, y = value, color = key)) +
  labs(x = "Time", y = "Malaria Incidence", 
       title = "Seasonal, lagged environmental, and autoregr. effects model")
```

##	Day 4 exercises

Run through the demonstration yourself by typing all of the commands above into a script on your computer, running each line of the script, and then examining the output on your computer. Whenever a new function is introduced, use `help()` to look it up and examine the various arguments that can be specified. Experiment with changing some of the arguments to see how they affect the output of the function.

Then, to pratice what you have learned, do the following exercises:

1. Repeat the synchrony analysis outlined in the demonstration for *Plasmodium falciparum*/mixed incidence and *Plasmodium vivax* incidence to whether one of the parasite species has stronger synchrony across districts.

2. Repeat the analysis of concordance among malaria for *Plasmoidum falciparum*/mixed malaria and *Plasmoidum vivax* malaria to determine whether the indicators are more consistent for one of the two species.

3. Repeat the environmental modeling analysis for Jabi Tehnan and compare the results with those for Fogera.



