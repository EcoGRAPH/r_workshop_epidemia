---
title: |
  | Introduction to R for Disease Surveillance 
  | and Outbreak Forecasting: Day 2
subtitle: Exploring data with effective visualizations
author: |
  | Michael Wimberly & Chris Merkord,
  | Geospatial Sciences Center of Excellence, South Dakota State University
date: June 18 2017, Addis Ababa, Ethiopia
output:
  pdf_document: default
  html_document: default
---

\pagenumbering{gobble}

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Outline

* Introduction
* Tibbles
    +	Creating
    + Printing
    + Subsetting
    + Using with older functions
* Plotting with ggplot2
    + Creating a ggplot
    + Aesthetic mappings
    + Facets
    + Geometric objects
    + The generalized ggplot template
`   + Other types of plots
* Manipulating data with dplyr
    + Single table verbs
* Exercises

## Introduction

This tutorial will teach you how to work with and visualize your data in R. The central theme today is the R object known as the data frame. By the end of today's lesson, you will be able to create, manipulate, read data into, and visualize the data in a data frame.

Over the past 20 years R has become increasingly popular for statistical programming. One of R's strengths has always been that it makes it easy for anybody to join the R community and contribute to R's capabilities by creating new packages, and recently the number of R packages on CRAN and elsewhere has grown at an astonishing rate. As a result, there are many new packages that improve on the data manipulation and plotting functions included with the basic R installation.

Here we begin to more fully explore three of those packages: tibble, dplyr, and ggplot2, three members of tidyverse. The tibble package makes creating and viewing data frames easier, while the dplyr packages provides powerful functions for manipulating data frames. Finally, ggplot2 offers a versatile system for plotting data frames.

## Tibbles

Throughout the rest of this workshop we will be working with "tibbles" instead of R's traditional "data frame". Tibbles actually _are_ data frames, but they change the way data frames work to reduce some of the problems caused by the limitations of the older `data.frame` class.

If you're wondering where the name came from, tibbles originally had the class `tbl_df`, which stood for "table" and "data frame". People soon began pronouncing this new class "tibble diff", and ultimately just "tibble".

Tibbles are defined in the tibble package, which can be loaded with the library function.

```{r}
library(tibble)
```

If you run this code and get the error message “there is no package called ‘tibble’”, you’ll need to first install it, then run `library()` once again.

```{r, eval=FALSE}
install.packages("tibble")
library(tibble)
```

You only need to install a package once, but you need to reload it every time you start a new session.

### Creating tibbles

Most of the functions in the tidyverse create tibbles, and all of them can accept tibbles as arguments. However many packages in R use traditional data frames. in which case you might want to coerce a data frame to a tibble using `as_tibble()`. Here is an example using the built in `iris` dataset, a data frame.

```{r}
as_tibble(iris)
```

Here you can see the built-in iris dataset has 150 rows and 5 columns.

You can create a new tibble from individual vectors with `tibble()`. `tibble()` will automatically recycle inputs of length 1, and allows you to refer to variables that you just created, as shown below.

```{r}
df <- tibble(
  woreda = "Mecha",
  epi_week = 1:5,
  epi_year = 2017,
  cases = c(10, 12, 7, 9, 5),
  population = 5129,
  incidence = cases / population * 1000
)
df
```

### Printing tibbles

Like other objects, a tibble can be printed in two ways.
```{r}
print(df)
```

or simply

```{r}
df
```

There are three main differences between how a tibble is printed in your console and how a data frame is printed. To illustrate the differences, we will use the `flights` dataset from nycflights13, a tidyverse package which contains example datasets.

```{r}
library(nycflights13)
str(flights)  # flights is a tibble (class tbl_df)
```

We won't print it here because it is too long, but to see what `flights` looks like in your console when printed as a `data.frame`, run this code:

```{r, results="hide"}
as.data.frame(flights)
```

Unless you have a very wide screen, you probably only see the last few columns and some of the rows, along with the message `reached getOption("max.print")`. The column names and first few rows are not visible unless you scroll up in your console window quite a bit. Compare that to how `flights` looks when printed as a tibble:

```{r}
flights
```

First, only the first 10 rows of the data frame are printed. Second, only columns that fit on the screen are printed. The remainder are listed at the bottom. Third, the class of each column is given beneath its name.

As a whole, these improvements make printing tibbles much easier on the eyes than printing data frames.

### Using tibbles with older functions

Some older functions don’t work with tibbles. If you find yourself unable to run an older function with a tibble, use `as.data.frame()` to turn it into a traditional data frame.

```{r, eval=FALSE}
as.data.frame(nycflights13::flights)
```

## Plotting with ggplot2

While R has several different systems for making plots (also called graphs or visualizations), the ggplot2 package is one of the most versatile because it allows you to use one system to visualize many different kinds of data.

To start, we will read in a simple dataset with which to practice plotting. The file `fogera.csv` contains one year of malaria case data from Fogera woreda. Read the dataset using `read_csv()` as you did yesterday.

```{r}
library(readr)
fogera <- read_csv("fogera.csv")
fogera
```

To access the ggplot2 functions and help pages, load the ggplot package:

```{r}
library(ggplot2)
```

### Creating a ggplot

One of the most common types of plot in epidemiology is a time series plot, in which the date or time element is on the x-axis and the measured variable of interest is on the y-axis. The data values are usually connected by a line to indicate progression through time.

Use this code to plot the number of malaria cases in Fogera during 2016.

```{r}
ggplot(data = fogera) +
  geom_line(mapping = aes(x = epi_week, y = mal_case))
```

You use `ggplot()` to create a coordinate system onto which you may add layers. The first argument to `ggplot()` is always `data`, the dataset to plot. You could run `ggplot(fogera)` to create just the blank coordinate system, but it's not very interesting so its not shown here.

Once you have a blank plot, you can add layers to it. For example, `geom_line()` in the example above adds lines to the plot. The `mapping` argument specifies the aesthetic mapping to use. Aesthetic mappings tell ggplot which columns in the dataset get used for (or "mapped to") which features of the plot. The mapping is always specified by the `aes()` function.

In our example, the mapping tells ggplot that the `epi_week` column contains x-axis values and the `mal_case` column contains y-axis values.

#### A reuseable template

The above code can be generalized to a reuseable template for plotting with `ggplot()`:

```{r, eval = FALSE}
ggplot(data = <DATA>) + 
  <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>))
```

#### Aesthetic mappings

You've already learned about mapping data columns to x and y axes. If you want to visualize a third column, you will have to map it to some other part of the plot. 

To illustrate, we will read in the dataset in `mecha.csv`, which contains the same variables as the Fogera dataset, but includes three years of data.

```{r}
mecha <- read_csv("mecha.csv")
```

Because there are three years of data in this dataset, we need some way to tell the lines for the three years apart. One common choice is to show different lines with different colors. Here we will "map" the `epi_year` column to the `color` aesthetic like this:

```{r}
ggplot(data = mecha) +
  geom_line(mapping = aes(x = epi_week, y = mal_case, color = epi_year))
```

Note that ggplot is treating epi_year as a continuous variable and trying to draw a line connecting points across years. This is the default behavior for data columns of class "numeric". To treat epi_year as a categorical variable, we can use `factor()` to convert the numerical vector of years to a categorical vector of years.

```{r}
mecha$epi_year <- factor(mecha$epi_year)
ggplot(data = mecha) +
  geom_line(mapping = aes(x = epi_week, y = mal_case, color = epi_year))
```

The blue color gradient used in the legend has been replaced by a discrete color legend with unique colors for each year. You can always tell whether ggplot is treating one of your variables as continuous or categorical by whether it uses a gradient or discrete color legend.

Other aesthetics for lines include linetype, size, and alpha, which controls transparency. For points, there is also a shape aesthetic.

You can even assign multiple aesthetics to the same column:

```{r}
ggplot(data = mecha) +
  geom_line(mapping = aes(x = epi_week, y = mal_case, 
                          color = epi_year, linetype = epi_year))
```

You can also set an aesthetic to a fixed value by defining that aesthetic outside of the `aes()` function. For example, to turn all the lines blue, you would use this:

```{r}
ggplot(data = mecha) +
  geom_line(aes(x = epi_week, y = mal_case, linetype = epi_year), 
            color = "blue")
```

Sometimes we want to plot groups of data but we don't want to map the groups to any particular aesthetic such as color or linetype. In these cases, you can use the `group` argument inside the `aes()` function:

```{r}
# no year aesthetic
ggplot(data = mecha) +
  geom_line(aes(x = epi_week, y = mal_case, group = epi_year), 
            color = "blue")
```

The years are still plotted correctly, but it is no longer possible to tell which year is which. This may be desirable if the goal is just to show the variability from year to year without identifying individual years.

For a complete overview of all the possible aesthetic specifications, run the command `vignette('ggplot2-specs')` to view the **Aesthetic specifications** vignette.

#### Facets

Another way to view additional variables on your plot is to use facets. Facetting allows you to split your dataset into subsets. 

For example, the plot above is very crowded with three years of data on it. It might be easier to read if each year of data was on its own subplot, or facet.

To facet by a single variable, use `facet_wrap()` like this.

```{r}
ggplot(data = mecha) +
  geom_line(mapping = aes(x = epi_week, y = mal_case)) +
  facet_wrap(~ epi_year)
``` 

Because these are time series data, it might be nice to have the stack the subplots on top of each other instead of having them side-by-side. You can change the layout using `ncol` or `nrow` to specify the number of colums or rows.

```{r}
ggplot(data = mecha) +
  geom_line(mapping = aes(x = epi_week, y = mal_case)) +
  facet_wrap(~ epi_year, ncol = 1)
``` 

You may notice that the maximum number of cases in 2014 was significantly higher than in other years, making it hard to see the seasonality 2015 and 2016. To allow the data in those years to stretch to take up the entire vertical space, you can use the `scales` argument. In this case, set it to `"free_y"`.

```{r}
ggplot(data = mecha) +
  geom_line(mapping = aes(x = epi_week, y = mal_case)) +
  facet_wrap(~ epi_year, ncol = 1, scales = "free_y")
``` 

Notice how the range of the y axis varies between subplots now.

#### Geometric objects

A **geom** is the geometrical object that a plot uses to represent data. There are often multiple ways to represent the same data visually. For example, we have been using line geometries to visualize our time series of malaria case data. An alternative might be to use points for each value.

The function for a point geom is `geom_point()`.

```{r}
ggplot(data = mecha) +
  geom_point(mapping = aes(x = epi_week, y = mal_case)) +
  facet_wrap(~ epi_year, ncol = 1, scales = "free_y")
``` 

You can even represent the same data using multiple geoms!

```{r}
ggplot(data = mecha) +
  geom_line(mapping = aes(x = epi_week, y = mal_case)) +
  geom_point(mapping = aes(x = epi_week, y = mal_case)) +
  facet_wrap(~ epi_year, ncol = 1, scales = "free_y")
```

Some aesthetics can only be used with certain geoms. For example, points can have a shape aesthetic, but lines cannot. Conversely, lines can have a linetype aesthetic, but points can not.

#### Scales

Scales control the details of how data values are translated to visual properties. We can override the default scales to tweak details like the axis labels or legend keys, or to use a completely different translation from data to aesthetic.

For example, to change the axis, legend, and plot labels we can use the `labs()` function:

```{r}
ggplot(data = mecha) +
  geom_line(mapping = aes(x = epi_week, y = mal_case, color = epi_year)) +
  labs(x = "Epi Week", y = "Number of Cases", color = "Year",
       title = "Malaria cases in Mecha over a 3-year period")
```

Other possible arguments to `labs()` include `subtitle`, `caption`, and any other aesthetics you have mapped, e.g. `linetype` or `shape`.

To adjust the limits of the x and y axes, you can use `lims()`:

```{r}
ggplot(data = mecha) +
  geom_line(mapping = aes(x = epi_week, y = mal_case, color = epi_year)) +
  lims(x = c(32, 42))
```

Other scales let you adjust the x and y axes even more. For example, to plot the y axis on the log scale, which is often desirable when dealing with count data where most values are low but a few very high values occur, you can use `scale_y_log10()`:

```{r}
ggplot(data = mecha) +
  geom_line(mapping = aes(x = epi_week, y = mal_case, color = epi_year)) +
  scale_y_log10()
```

To set the color manually, we can use `scale_color_manual()`:

```{r}
ggplot(data = mecha) +
  geom_line(mapping = aes(x = epi_week, y = mal_case, color = epi_year)) +
  scale_color_manual(values = c("orange", "purple", "brown"))
```

Colors can be specified in several ways in R. The simplest way is with a character string giving the color name (e.g., "red"). A list of the possible colors can be obtained with the function `colors()`. Alternatively, colors can be specified directly in terms of their RGB components with a string of the form "#RRGGBB". For more information see the "Color Specification" section under `help("par")`.

Each aesthetic has its own scale functions, e.g. `scale_linetype()` and `scale_size()`. For more on scales, the best references is the ggplot documentation website: http://ggplot2.tidyverse.org/reference/#section-scales. 

#### The generalized ggplot template

Up to this point, you have learned how to:

1. create a ggplot using `ggplot()` 
2. add geometric representations of data to a plot using geoms
3. map data columns to plot aesthetics
4. split your dataset into subplots using facets.
5. control the visual properties of your plot using scales

These steps can be combined to create generalized code for plotting in ggplot.

```{r, eval = FALSE}
ggplot(data = <DATA>) + 
  <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>)) +
  <FACET_FUNCTION> +
  <SCALE_FUNCTION> +
  <SCALE_FUNCTION>
```

This is the template that we use for most of the plots in this workshop. Once you master it, the plots you can create will allow you to learn a lot about your data. This process is part of *data exploration*.

On the other hand, communicating your understanding to others requires considerable effort in making your plots as self-explanatory as possible. To learn more about how to do this, we recommend the "Graphics for communication" chapter of "R for Data Science" by Grolemund and Wickham: http://r4ds.had.co.nz/graphics-for-communication.html.

### Other types of plots

#### Scatterplot

Scatterplots are used to show the relationship between two variables. They are like time series plots, but they always use points for the geometry and both axes are measured variables rather than just the y axis.

```{r}
ggplot(data = mecha) +
  geom_point(mapping = aes(x = tot_case, y = mal_case, color = epi_year))
```

#### Histograms

A histogram is a graphical representation of the distribution of numerican data. It usually has boxes whose area is proportional to the frequency of a class of values. In this example, we will plot the frequency of malaria count data in the fogera dataset.

```{r}
ggplot(fogera) +
  geom_histogram(aes(x = mal_case), bins = 10)
```

Each column represents a discrete "bin", or range of values. The height of the rectangles represents the number of values in the bin, i.e. the number of weeks where the number of malaria cases fell within the values covered by the bin.

#### Boxplots

Like histograms, boxplots also visualize the distribution of data.

```{r}
ggplot(mecha) +
  geom_boxplot(aes(epi_year, rdt_pv))
```

In ggplot, the horizontal line represents the median value, the box represents the inter quartile range (IQR), i.e. the 25th through 75th percentiles. The upper whisker extends from the hinge to the largest value no further than `1.5 * IQR` from the hinge (where IQR is the inter-quartile range, or distance between the first and third quartiles). The lower whisker extends from the hinge to the smallest value at most `1.5 * IQR` of the hinge. Data beyond the end of the whiskers are called "outlying" points and are plotted individually.

## Data transformations

You now have a solid background in plotting data with ggplot. But what happens when your data is not already in the correct format for plotting? Or what if you want to plot only a subset of your data?

In this part of the demonstration, you will learn the basic commands for manipulating data frames (and tibbles). Such manipulations can be accomplished in a variety of ways, but the most intuitive and efficient way is by using the functions provided in the **dplyr** package.

dplyr is a member of the tidyverse which focuses exclusively on manipulating data frames.

Start by loading dplyr.

```{r}
library(dplyr)
```

The dplyr package has some excellent vignettes, including an Introduction to dplyr which can be accessed by running `vignette("dplyr")`

### Single table verbs

Each data transformation has a corresponding dplyr function that accomplishes it. These functions take the form of verbs that describe the action. Some dplyr verbs operate on a single data frame or tibble, while others operate on two or more tables. Here is a list of the main dplyr verbs for single tables:

* `filter()` selects observations (rows) based on their values.
* `arrange()` reorders  observations.
* `select()` and `rename()` select variables (columns) based on their names.
* `mutate()` and `transmute()` add new variables that are functions of existing variables.

#### Filter

```{r}
filter(mecha, epi_week == 1)
filter(mecha, epi_year %in% 2014:2015)
filter(mecha, mal_case > 200, epi_year != 2016)
```

#### Arrange

```{r}
arrange(mecha, epi_week)
```

Use `desc()` to order a column in descending rather than ascending order.

```{r}
arrange(mecha, desc(mal_case))
```

#### Select and Rename

Select columns to keep by name. Other columns are removed from the data frame.

```{r}
select(mecha, woreda, epi_year, epi_week, mal_case)
```

Use the `:` operator to select a continuous series of columns. The helper functions `starts_with()`, `ends_with()`, and `contains()` can be used to find multiple columns by matching part of the column name.

```{r}
select(mecha, 
       woreda:epi_week, 
       starts_with("rdt"))
```

Remove columns by prefixing their names with a `-`. Other columns will be kept.

```{r}
select(mecha, 
       -zone, 
       -popul_tot)
```

Rename columns using the `=` operator, placing the new name first and the old name second.

```{r}
rename(mecha, district = woreda, 
       malaria_case = mal_case)
```

#### Mutate and Transmute

Add new variables using `mutate()`. You can create multiple new variables at a time, and you can refer to ones you've just created. 

```{r}
mutate(mecha, 
       inc = mal_case / popul_tot,
       inc_per_1000 = inc * 1000)
```

If you only want to keep the new variables, use `transmute()`.

```{r}
transmute(mecha, 
       inc = mal_case / popul_tot,
       inc_per_1000 = inc * 1000)
```

## Day 2 exercises

1. Read the data file `harmonized.csv`.
4. Create new columns showing the incidences of total malaria, confirmed P. falciparum malaria, and confirmed P. vivax malaria.
5. Create a time series plot of confirmed P. vivax malaria incidence `pv_inc`. Show each year as a different color.
6. Do the same, but facet by woreda.
7. Facet by woreda *and* year using `facet_grid()`. You will need to use `help("facet_grid")` to learn how to specify the faceting in this new function.
8. Create a scatterplot showing the relationship between confirmed P. falciparum malaria incidence and Normalized Difference Vegetation Index (in the `ndvi_obs` column).
